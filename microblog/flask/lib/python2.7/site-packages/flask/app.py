# -*- coding: utf-8 -*-

from .helpers import _PackageBoundObject, find_package
import os
from .config import Config
from werkzeug.datastructures import ImmutableDict
from datetime import timedelta
from .templating import _default_template_ctx_processor
from werkzeug.routing import Map
from threading import Lock
from werkzeug.routing import Rule
from .helpers import _endpoint_from_view_func

class Flask(_PackageBoundObject):
    """
    flask对象实现WSGI应用程序，并充当核心对象。它以模块或应用程序包的名称传递。它一旦被创建，对于视图函数,URL规则,template配置以及更多，它将作为一个一个中央注册。
    
    程序包的名称用来解决内部的资源，包或模块中所是否被包含取决于软件包参数是否解析为实际python包(一个里面有'__init__.py'文件的文件夹)或一个标准的模块(仅仅是一个'py'文件)

    关于资源加载的更多信息，请参阅:func'open_resource'。

    通常在你的函数模块您创建一个'Flask'实例或在你的包里的'__init__.py'文件内:

	    from flask import Flask
	    app = Flask(__name__)
	    ...警告::关于第一个参数

	    第一个参数的想法是让flask了解什么属于您的应用程序。这个名字被用来发现文件系统上的资源，可用于扩展改善调试信息或更多。

	    所以，你提供什么是很重要的。如果您是用单个模块，'__name__'始终是正确的值。如果你不过是使用一个包，它通常建议使用硬编码以及你包的名称。

	    例如如果你的应用在'yourapplication/app.py'被定义，你应该通过下面两个方式创建:

		    app = Flask('yourapplication')
		    app = Flask(__name__.split('.')[0])

	    这是为什么?该应用程序甚至与'__name__'工作，为了查找资源。然而它会使调试更加痛苦。某些扩展可能基于你的应用的导入名为基础做出假设。例如Flask-SQLAlchemy扩展在debug模式下将会寻找您触发SQL查询的应用程序中的代码。如果导入的名称设置不正确，调试信息将会丢失。(例如它只会在'yourapplication.app'而不会在'yourapplication.views.frontend'中导入SQL查询语句)

	    ..versionadded:: 0.7
	    'static_url_path','static_folder'以及'template_folder'参数被添加
	    
	    ..versionadded:: 0.8
	    'instance_path'以及'instance_relative_config'参数被添加

	    :参数 import_name:	应用程序的名称
	    :参数 static_url_path: 可以用来指定位于web上的静态文件不同路径。默认为'static_folder'文件夹的名称。
	    :参数 template_folder: 包含应用程序应使用的模板的文件夹。默认为'templates'应用程序的根路径中的文件夹。
	    :参数 instance_path: 应用程序替代实例路径。默认情况下包或者模块旁的文件夹'instance'被认为是实例路径。
	    :参数 instance_relative_config: 如果设置当加载config时相对文件名为True，被假定为相对于实例而不是应用程序根目录的路经。
    """
    #: 该类被用来作为request对象。参阅:class:'~flask.Request'获取更多信息
    #request_class = Request
    
    #: 该类被用来作为响应对象。参阅:class:'flask.Response'获取更多信息
    #response_class = Response

    #: 该类被用作:data:'~flask.g'实例。
    #:
    #: 例如对于一个custom类使用例子:
    #: 1. 将任意属性存储在flask.g上。
    #: 2. 添加

    #app_ctx_globals_class = _AppCtxGlobals

    # Backwards compatibility support
    #def _get_request_globals_class(self):


    def __init__(self, import_name, static_path=None, static_url_path=None,
		 static_folder='static', template_folder='templates',
		 instance_path=None, instance_relative_config=False):
	_PackageBoundObject.__init__(self, import_name,
				     template_folder=template_folder)
	if static_path is not None:
	    from warnings import warn
	    warn(DeprecationWarning('static_path is now called '
				    'static_url_path'), stacklevel=2)
	    static_url_path = static_path

	if static_url_path is not None:
	    self.static_url_path = static_url_path
	if static_folder is not None:
	    self.static_folder = static_folder
	if instance_path is None:
	    instance_path = self.auto_find_instance_path()
	elif not os.path.isabs(instance_path):
	    raise ValueError('If an instance path is provided it must be '
			     'absolute.  A relative path was given instead.')

	#: Holds the path to the instance folder.
	#:
	#: .. versionadded:: 0.8
	self.instance_path = instance_path

	#: The configuration dictionary as :class:`Config`.  This behaves
	#: exactly like a regular dictionary but supports additional methods
	#: to load a config from files.
	self.config = self.make_config(instance_relative_config)

	# Prepare the deferred setup of the logger.
	self._logger = None
	self.logger_name = self.import_name

	#: A dictionary of all view functions registered.  The keys will
	#: be function names which are also used to generate URLs and
	#: the values are the function objects themselves.
	#: To register a view function, use the :meth:`route` decorator.
	self.view_functions = {}

	# support for the now deprecated `error_handlers` attribute.  The
	# :attr:`error_handler_spec` shall be used now.
	self._error_handlers = {}

	#: A dictionary of all registered error handlers.  The key is `None`
	#: for error handlers active on the application, otherwise the key is
	#: the name of the blueprint.  Each key points to another dictionary
	#: where they key is the status code of the http exception.  The
	#: special key `None` points to a list of tuples where the first item
	#: is the class for the instance check and the second the error handler
	#: function.
	#:
	#: To register a error handler, use the :meth:`errorhandler`
	#: decorator.
	self.error_handler_spec = {None: self._error_handlers}

	#: A list of functions that are called when :meth:`url_for` raises a
	#: :exc:`~werkzeug.routing.BuildError`.  Each function registered here
	#: is called with `error`, `endpoint` and `values`.  If a function
	#: returns `None` or raises a `BuildError` the next function is
	#: tried.
	#:
	#: .. versionadded:: 0.9
	self.url_build_error_handlers = []

	#: A dictionary with lists of functions that should be called at the
	#: beginning of the request.  The key of the dictionary is the name of
	#: the blueprint this function is active for, `None` for all requests.
	#: This can for example be used to open database connections or
	#: getting hold of the currently logged in user.  To register a
	#: function here, use the :meth:`before_request` decorator.
	self.before_request_funcs = {}

	#: A lists of functions that should be called at the beginning of the
	#: first request to this instance.  To register a function here, use
	#: the :meth:`before_first_request` decorator.
	#:
	#: .. versionadded:: 0.8
	self.before_first_request_funcs = []

	#: A dictionary with lists of functions that should be called after
	#: each request.  The key of the dictionary is the name of the blueprint
	#: this function is active for, `None` for all requests.  This can for
	#: example be used to open database connections or getting hold of the
	#: currently logged in user.  To register a function here, use the
	#: :meth:`after_request` decorator.
	self.after_request_funcs = {}

	#: A dictionary with lists of functions that are called after
	#: each request, even if an exception has occurred. The key of the
	#: dictionary is the name of the blueprint this function is active for,
	#: `None` for all requests. These functions are not allowed to modify
	#: the request, and their return values are ignored. If an exception
	#: occurred while processing the request, it gets passed to each
	#: teardown_request function. To register a function here, use the
	#: :meth:`teardown_request` decorator.
	#:
	#: .. versionadded:: 0.7
	self.teardown_request_funcs = {}

	#: A list of functions that are called when the application context
	#: is destroyed.  Since the application context is also torn down
	#: if the request ends this is the place to store code that disconnects
	#: from databases.
	#:
	#: .. versionadded:: 0.9
	self.teardown_appcontext_funcs = []

	#: A dictionary with lists of functions that can be used as URL
	#: value processor functions.  Whenever a URL is built these functions
	#: are called to modify the dictionary of values in place.  The key
	#: `None` here is used for application wide
	#: callbacks, otherwise the key is the name of the blueprint.
	#: Each of these functions has the chance to modify the dictionary
	#:
	#: .. versionadded:: 0.7
	self.url_value_preprocessors = {}

	#: A dictionary with lists of functions that can be used as URL value
	#: preprocessors.  The key `None` here is used for application wide
	#: callbacks, otherwise the key is the name of the blueprint.
	#: Each of these functions has the chance to modify the dictionary
	#: of URL values before they are used as the keyword arguments of the
	#: view function.  For each function registered this one should also
	#: provide a :meth:`url_defaults` function that adds the parameters
	#: automatically again that were removed that way.
	#:
	#: .. versionadded:: 0.7
	self.url_default_functions = {}

	#: A dictionary with list of functions that are called without argument
	#: to populate the template context.  The key of the dictionary is the
	#: name of the blueprint this function is active for, `None` for all
	#: requests.  Each returns a dictionary that the template context is
	#: updated with.  To register a function here, use the
	#: :meth:`context_processor` decorator.
	self.template_context_processors = {
	    None: [_default_template_ctx_processor]
	}

	#: all the attached blueprints in a dictionary by name.  Blueprints
	#: can be attached multiple times so this dictionary does not tell
	#: you how often they got attached.
	#:
	#: .. versionadded:: 0.7
	self.blueprints = {}

	#: a place where extensions can store application specific state.  For
	#: example this is where an extension could store database engines and
	#: similar things.  For backwards compatibility extensions should register
	#: themselves like this::
	#:
	#:	if not hasattr(app, 'extensions'):
	#:	    app.extensions = {}
	#:	app.extensions['extensionname'] = SomeObject()
	#:
	#: The key must match the name of the `flaskext` module.  For example in
	#: case of a "Flask-Foo" extension in `flaskext.foo`, the key would be
	#: ``'foo'``.
	#:
	#: .. versionadded:: 0.7
	self.extensions = {}

	#: The :class:`~werkzeug.routing.Map` for this instance.  You can use
	#: this to change the routing converters after the class was created
	#: but before any routes are connected.  Example::
	#:
	#:    from werkzeug.routing import BaseConverter
	#:
	#:    class ListConverter(BaseConverter):
	#:	  def to_python(self, value):
	#:	      return value.split(',')
	#:	  def to_url(self, values):
	#:	      return ','.join(BaseConverter.to_url(value)
	#:			      for value in values)
	#:
	#:    app = Flask(__name__)
	#:    app.url_map.converters['list'] = ListConverter
	self.url_map = Map()

	# tracks internally if the application already handled at least one
	# request.
	self._got_first_request = False
	self._before_request_lock = Lock()

	# register the static folder for the application.  Do that even
	# if the folder does not exist.  First of all it might be created
	# while the server is running (usually happens during development)
	# but also because google appengine stores static files somewhere
	# else when mapped with the .yml file.
	if self.has_static_folder:
	    self.add_url_rule(self.static_url_path + '/<path:filename>',
			      endpoint='static',
			      view_func=self.send_static_file)

    def auto_find_instance_path(self):
        """Tries to locate the instance path if it was not provided to the
        constructor of the application class.  It will basically calculate
        the path to a folder named ``instance`` next to your main file or
        the package.

        .. versionadded:: 0.8
        """
        prefix, package_path = find_package(self.import_name)
        if prefix is None:
            return os.path.join(package_path, 'instance')
        return os.path.join(prefix, 'var', self.name + '-instance')

    def make_config(self, instance_relative=False):
        """Used to create the config attribute by the Flask constructor.
        The `instance_relative` parameter is passed in from the constructor
        of Flask (there named `instance_relative_config`) and indicates if
        the config should be relative to the instance path or the root path
        of the application.

        .. versionadded:: 0.8
        """
        root_path = self.root_path
        if instance_relative:
            root_path = self.instance_path
        return Config(root_path, self.default_config)
    
    default_config = ImmutableDict({
        'DEBUG':                                False,
        'TESTING':                              False,
        'PROPAGATE_EXCEPTIONS':                 None,
        'PRESERVE_CONTEXT_ON_EXCEPTION':        None,
        'SECRET_KEY':                           None,
        'PERMANENT_SESSION_LIFETIME':           timedelta(days=31),
        'USE_X_SENDFILE':                       False,
        'LOGGER_NAME':                          None,
        'SERVER_NAME':                          None,
        'APPLICATION_ROOT':                     None,
        'SESSION_COOKIE_NAME':                  'session',
        'SESSION_COOKIE_DOMAIN':                None,
        'SESSION_COOKIE_PATH':                  None,
        'SESSION_COOKIE_HTTPONLY':              True,
        'SESSION_COOKIE_SECURE':                False,
        'MAX_CONTENT_LENGTH':                   None,
        'SEND_FILE_MAX_AGE_DEFAULT':            12 * 60 * 60, # 12 hours
        'TRAP_BAD_REQUEST_ERRORS':              False,
        'TRAP_HTTP_EXCEPTIONS':                 False,
        'PREFERRED_URL_SCHEME':                 'http',
        'JSON_AS_ASCII':                        True,
        'JSON_SORT_KEYS':                       True,
        'JSONIFY_PRETTYPRINT_REGULAR':          True,
    })

    url_rule_class = Rule

    def add_url_rule(self, rule, endpoint=None, view_func=None, **options):
        """Connects a URL rule.  Works exactly like the :meth:`route`
        decorator.  If a view_func is provided it will be registered with the
        endpoint.

        Basically this example::

            @app.route('/')
            def index():
                pass

        Is equivalent to the following::

            def index():
                pass
            app.add_url_rule('/', 'index', index)

        If the view_func is not provided you will need to connect the endpoint
        to a view function like so::

            app.view_functions['index'] = index

        Internally :meth:`route` invokes :meth:`add_url_rule` so if you want
        to customize the behavior via subclassing you only need to change
        this method.

        For more information refer to :ref:`url-route-registrations`.

        .. versionchanged:: 0.2
           `view_func` parameter added.

        .. versionchanged:: 0.6
           `OPTIONS` is added automatically as method.

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param view_func: the function to call when serving a request to the
                          provided endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.  A change
                        to Werkzeug is handling of method options.  methods
                        is a list of methods this rule should be limited
                        to (`GET`, `POST` etc.).  By default a rule
                        just listens for `GET` (and implicitly `HEAD`).
                        Starting with Flask 0.6, `OPTIONS` is implicitly
                        added and handled by the standard request handling.
        """
        if endpoint is None:
            endpoint = _endpoint_from_view_func(view_func)
        options['endpoint'] = endpoint
        methods = options.pop('methods', None)

        # if the methods are not given and the view_func object knows its
        # methods we can use that instead.  If neither exists, we go with
        # a tuple of only `GET` as default.
        if methods is None:
            methods = getattr(view_func, 'methods', None) or ('GET',)
        methods = set(methods)

        # Methods that should always be added
        required_methods = set(getattr(view_func, 'required_methods', ()))

        # starting with Flask 0.8 the view_func object can disable and
        # force-enable the automatic options handling.
        provide_automatic_options = getattr(view_func,
            'provide_automatic_options', None)

        if provide_automatic_options is None:
            if 'OPTIONS' not in methods:
                provide_automatic_options = True
                required_methods.add('OPTIONS')
            else:
                provide_automatic_options = False

        # Add the required methods now.
        methods |= required_methods

        # due to a werkzeug bug we need to make sure that the defaults are
        # None if they are an empty dictionary.  This should not be necessary
        # with Werkzeug 0.7
        options['defaults'] = options.get('defaults') or None

        rule = self.url_rule_class(rule, methods=methods, **options)
        rule.provide_automatic_options = provide_automatic_options

        self.url_map.add(rule)
        if view_func is not None:
            old_func = self.view_functions.get(endpoint)
            if old_func is not None and old_func != view_func:
                raise AssertionError('View function mapping is overwriting an '
                                     'existing endpoint function: %s' % endpoint)
            self.view_functions[endpoint] = view_func

    def route(self, rule, **options):
        """A decorator that is used to register a view function for a
        given URL rule.  This does the same thing as :meth:`add_url_rule`
        but is intended for decorator usage::

            @app.route('/')
            def index():
                return 'Hello World'

        For more information refer to :ref:`url-route-registrations`.

        :param rule: the URL rule as string
        :param endpoint: the endpoint for the registered URL rule.  Flask
                         itself assumes the name of the view function as
                         endpoint
        :param options: the options to be forwarded to the underlying
                        :class:`~werkzeug.routing.Rule` object.  A change
                        to Werkzeug is handling of method options.  methods
                        is a list of methods this rule should be limited
                        to (`GET`, `POST` etc.).  By default a rule
                        just listens for `GET` (and implicitly `HEAD`).
                        Starting with Flask 0.6, `OPTIONS` is implicitly
                        added and handled by the standard request handling.
        """
        def decorator(f):
            endpoint = options.pop('endpoint', None)
            self.add_url_rule(rule, endpoint, f, **options)
            return f
        return decorator

    def run(self, host=None, port=None, debug=None, **options):
        """Runs the application on a local development server.  If the
        :attr:`debug` flag is set the server will automatically reload
        for code changes and show a debugger in case an exception happened.

        If you want to run the application in debug mode, but disable the
        code execution on the interactive debugger, you can pass
        ``use_evalex=False`` as parameter.  This will keep the debugger's
        traceback screen active, but disable code execution.

        .. admonition:: Keep in Mind

           Flask will suppress any server error with a generic error page
           unless it is in debug mode.  As such to enable just the
           interactive debugger without the code reloading, you have to
           invoke :meth:`run` with ``debug=True`` and ``use_reloader=False``.
           Setting ``use_debugger`` to `True` without being in debug mode
           won't catch any exceptions because there won't be any to
           catch.

        .. versionchanged:: 0.10
           The default port is now picked from the ``SERVER_NAME`` variable.

        :param host: the hostname to listen on. Set this to ``'0.0.0.0'`` to
                     have the server available externally as well. Defaults to
                     ``'127.0.0.1'``.
        :param port: the port of the webserver. Defaults to ``5000`` or the
                     port defined in the ``SERVER_NAME`` config variable if
                     present.
        :param debug: if given, enable or disable debug mode.
                      See :attr:`debug`.
        :param options: the options to be forwarded to the underlying
                        Werkzeug server.  See
                        :func:`werkzeug.serving.run_simple` for more
                        information.
        """
        from werkzeug.serving import run_simple
        if host is None:
            host = '127.0.0.1'
        if port is None:
            server_name = self.config['SERVER_NAME']
            if server_name and ':' in server_name:
                port = int(server_name.rsplit(':', 1)[1])
            else:
                port = 5000
        if debug is not None:
            self.debug = bool(debug)
        options.setdefault('use_reloader', self.debug)
        options.setdefault('use_debugger', self.debug)
        try:
            run_simple(host, port, self, **options)
        finally:
            # reset the first request information if the development server
            # resetted normally.  This makes it possible to restart the server
            # without reloader and that stuff from an interactive shell.
            self._got_first_request = False

